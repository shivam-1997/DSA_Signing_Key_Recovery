
# This file was *autogenerated* from the file noise_free.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_9 = Integer(9); _sage_const_8 = Integer(8); _sage_const_160 = Integer(160)
from sage.crypto.lwe import *
from sage.modules.free_module_integer import IntegerLattice
import numpy as np

def bin2decimal(string):
    string = string[::-_sage_const_1 ]
    num = _sage_const_0 
    factor = _sage_const_1 
    for i in string:
        if i == '1':
            num = num + _sage_const_1 *factor
        factor *= _sage_const_2 
    return num


def createDiagMat(n):
    D = np.identity(_sage_const_2 *n)
    max_block_size = Integer(_sage_const_0 )
    for i in range(n):
        if S[i][_sage_const_9 ] > max_block_size:
            max_block_size = S[i][_sage_const_9 ]

    # S = (r-0, s-1, k-2, h(m)-3, l_a-4, l_b-5, l_c-6, a -7, c-8, no of bits leaked-9)
    for i in range(n):
        l_b = S[i][_sage_const_5 ]
        l_c = S[i][_sage_const_6 ]
        l_d = Integer(_sage_const_160 ) - l_c
        D[i][i] = _sage_const_2 **(max_block_size - max(l_b, l_d))

    return D

def createCVP(S, n, q):
    # O
    B = np.zeros((_sage_const_2 *n, _sage_const_2 *n))
    # I_n+1_x_n+1
    I = np.identity(n+_sage_const_1 )
    B[:n+_sage_const_1 , :n+_sage_const_1 ] = I
    # qI_n-1
    qI = q*np.identity(n-_sage_const_1 )
    B[n+_sage_const_1 :, n+_sage_const_1 :] = qI

    w_1 = []; w_2 = []
    x = []; y = []
    v = []; u = []
    for i in range(n+_sage_const_1 ):
        # S = (r-0, s-1, k-2, h(m)-3, l_a-4, l_b-5, l_c-6, a -7, c-8, no of bits leaked-9)
        r = S[i][_sage_const_0 ]; s = S[i][_sage_const_1 ]
        l_a = S[i][_sage_const_4 ]; l_b = S[i][_sage_const_5 ]; l_c = S[i][_sage_const_6 ]
        a = bin2decimal( S[i][_sage_const_7 ] )
        c = bin2decimal( S[i][_sage_const_8 ] ) #* (2 ^ l_b)
        m = S[i][_sage_const_3 ]
        y.append(-(r/s)*(_sage_const_2 **l_a))
        x.append((-(m/c) + c*(_sage_const_2 **l_b) + a)*(_sage_const_2 **l_a))

        if i != _sage_const_0 :
            w_1.append(y[i]/y[_sage_const_0 ])
            w_2.append((y[i]/y[_sage_const_0 ]) * (_sage_const_2  ** (l_c - l_a)))
            u.append(-(_sage_const_2  ** (l_c - l_a)))
            v.append(x[i] - (y[i]/y[_sage_const_0 ]) * x[_sage_const_0 ])

    w_1 = np.array(w_1)
    w_2 = np.array(w_2)
    B[_sage_const_0 ][n:] = w_1
    B[_sage_const_1 ][n:] = w_2
    for i in range(_sage_const_2 , n+_sage_const_1 ):
        B[i][(i-_sage_const_2 )+n] = u[i-_sage_const_2 ]
    V = np.zeros(_sage_const_2 *n)
    V[n:] = v
    return [B, V]

def CVP2SVP(B, t, n, q):
    n = Integer(n) + Integer(_sage_const_1 )
    B_dash = np.zeros((n, n))
    B_dash[:-_sage_const_1 , :-_sage_const_1 ] = B
    B_dash[-_sage_const_1 , :-_sage_const_1 ] = t
    B_dash[-_sage_const_1 ][-_sage_const_1 ] = q

    return B_dash


def compute_key(b_d, n, S):
    d=[]
    for i in range(_sage_const_1 ,n+_sage_const_1 ):
        d.append(b_d[i])
    # print(len(d))

    b = []
    b.append(b_d[_sage_const_0 ])
    for i in range(n+_sage_const_1 , _sage_const_2 *n):
        b.append(b_d[i])
    # print(len(b))

    result = []
    for i in range(n):
        l_a = S[i][_sage_const_4 ]
        l_b = S[i][_sage_const_5 ]
        l_c = S[i][_sage_const_6 ]
        a = bin2decimal(S[i][_sage_const_7 ])
        b_i = (b[i]*(_sage_const_2  ** l_a))
        c = bin2decimal(S[i][_sage_const_8 ])*(_sage_const_2  ** l_b)
        d_i = (d[i]*(_sage_const_2  ** l_c))
        result.append( a + b_i + c + d_i )
    result.append(Integer(_sage_const_0 ))
    return result

def findKey(S, correctKey, q):

    total_leaked_bits = _sage_const_0 
    gamma_min = _sage_const_0 
    for i in S:
        total_leaked_bits += i[_sage_const_9 ]
        gamma_min += _sage_const_1 
        if total_leaked_bits >= _sage_const_160 :
            break

    print("gamma min = ",gamma_min)
    keyNotFound = True
    i = gamma_min
    # i=140
    maxIter = len(S)
    computedKey = _sage_const_0 
    while i <= maxIter and keyNotFound == True:
        print('number of samples = ', i)
        [cvpBasis, v] = createCVP(S, i, q)

        cvpBasis = [map(int, j) for j in cvpBasis]
        cvpL = matrix(ZZ, cvpBasis)
        
        for j in range(len(v)):
            v[j] = int(v[j])

        svpBasis = CVP2SVP(cvpBasis, v, len(cvpBasis), q)
        svpBasis = [map(int, j) for j in svpBasis]
        svpL = matrix(ZZ, svpBasis)
        
        '''Solving using CVP'''
        # cvpReducedL = IntegerLattice( cvpL.LLL() )
        # print('LLL done')
        # result = cvpReducedL.closest_vector(v)
        '''end'''

        svpReducedL = IntegerLattice(svpL.LLL())
        # svpReducedL = svpL.BKZ()
        result = svpReducedL.shortest_vector()
        
        # print(correctKey)
        # print(result)
        computedKey = compute_key(result, i, S)
        
        Q = IntegerModRing(q)
        for j in range(i):
            print 'myk',computedKey[j]
            print 'ack', S[i][_sage_const_2 ]
            print 'crA',correctKey
            s = S[j][_sage_const_1 ]
            k = S[j][_sage_const_2 ]
            m = S[j][_sage_const_3 ]
            r = S[j][_sage_const_0 ]
            # alpha = (s*k-m)*Q(1/r)
            alpha = (s*computedKey[j]-m)*Q(_sage_const_1 /r)

            print 'myA', alpha
            print 
            if alpha == correctKey:
                input("true")
                return computedKey
            if computedKey[j] == k:
                input("TRUE")
        else:
            i = i+_sage_const_5 


if __name__ == "__main__":

    f = open("./files/private_key.pem", "r")
    correctKey = ZZ(f.readline())
    f.close()
    f = open("./files/q.pem", "r")
    q = ZZ(f.readline())
    f.close()
    EKOs_list = [] 
    f = open("./files/list.csv", "r")
    S = f.readlines()
    for line in S:
        # S = (r-0, s-1, k-2, h(m)-3, l_a-4, l_b-5, l_c-6, a -7, c-8, no of bits leaked-9)
        line = line.split(',')
        r = ZZ(line[_sage_const_0 ]) 
        s = ZZ(line[_sage_const_1 ])
        k = ZZ(line[_sage_const_2 ])
        m = ZZ(line[_sage_const_3 ])
        l_a = ZZ(line[_sage_const_4 ])
        l_b = ZZ(line[_sage_const_5 ])
        l_c = ZZ(line[_sage_const_6 ])
        a = line[_sage_const_7 ]
        c = line[_sage_const_8 ]
        bits = ZZ(line[_sage_const_9 ])
        EKOs_list.append([r, s, k, m, l_a, l_b, l_c, a, c, bits])
    f.close()
    # print(len(EKOs_list))
    print (findKey(EKOs_list, correctKey, q))
    

