
# This file was *autogenerated* from the file generation.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_1p0 = RealNumber('1.0'); _sage_const_9 = Integer(9); _sage_const_8 = Integer(8); _sage_const_13 = Integer(13); _sage_const_12 = Integer(12); _sage_const_11 = Integer(11); _sage_const_10 = Integer(10); _sage_const_16 = Integer(16); _sage_const_15 = Integer(15); _sage_const_14 = Integer(14); _sage_const_150 = Integer(150); _sage_const_1024 = Integer(1024)
from Crypto.Random import random
from Crypto.PublicKey import DSA
from Crypto.Hash import SHA

def find_x01_sequence_util(n):
    n = n[::-_sage_const_1 ]
    flag = _sage_const_0 
    sm = ''
    for i in n:
        if flag == _sage_const_0 :
            sm = sm + i
            if i == '1':
                flag = _sage_const_1 
        else: 
            sm = sm + 'x'
    return (sm[::-_sage_const_1 ])

def find_x01_sequence(string):
    n = len(string)
    i=_sage_const_0 
    x01_sequence = ''
    while i<n:        
        if string[i] == '0':
            count = _sage_const_0 
            flag_non_zero = _sage_const_0 
            short_string = ''
            for j in range(_sage_const_4 ):
                if i+j == n:
                    break
                if string[i+j] != '0':
                    flag_non_zero = _sage_const_1 
                    break
                
                count += _sage_const_1 
            if flag_non_zero == _sage_const_1 :
                x01_sequence += 'x'
            else:
                x01_sequence += '0'*count
            i = i + count
        else:
            count = _sage_const_0 
            short_string = ''
            for j in range(_sage_const_4 ):
                if i+j==n:
                    break
                short_string = short_string + string[i+j]
                count += _sage_const_1 
            x01_sequence = x01_sequence + find_x01_sequence_util(short_string)
            # print(short_string,find_x01_sequence_util(short_string))
            i = i + count 
    # print(x01_sequence)
    return x01_sequence

# find_x01_sequence('110010111000010100000011100110')

def convert(k):
    num = []
    EK = []
    # here by default window_size is considered to be 4
    while k > _sage_const_0 :
        rem = k%_sage_const_16 
        k = k//_sage_const_16 
        if rem == _sage_const_0 :
            EK.append('0000')
            num.append(_sage_const_0 )
        elif rem == _sage_const_1 :
            EK.append('0001')
            num.append(_sage_const_1 )
        elif rem == _sage_const_2 :
            EK.append('0010')
            num.append(_sage_const_2 )
        elif rem == _sage_const_3 :
            EK.append('0011')
            num.append(_sage_const_3 )
        elif rem == _sage_const_4 :
            EK.append('0100')
            num.append(_sage_const_4 )
        elif rem == _sage_const_5 :
            EK.append('0101')
            num.append(_sage_const_5 )
        elif rem == _sage_const_6 :
            EK.append('0110')
            num.append(_sage_const_6 )
        elif rem == _sage_const_7 :
            EK.append('0111')
            num.append(_sage_const_7 )
        elif rem == _sage_const_8 :
            EK.append('1000')
            num.append(_sage_const_8 )
        elif rem == _sage_const_9 :
            EK.append('1001')
            num.append(_sage_const_9 )
        elif rem == _sage_const_10 :
            EK.append('1010')
            num.append('a')
        elif rem == _sage_const_11 :
            EK.append('1011')
            num.append('b')
        elif rem == _sage_const_12 :
            EK.append('1100')
            num.append('c')
        elif rem == _sage_const_13 :
            EK.append('1101')
            num.append('d')
        elif rem == _sage_const_14 :
            EK.append('1110')
            num.append('e')
        elif rem == _sage_const_15 :
            EK.append('1111')
            num.append('f')
   
    num.reverse()
    # print(num)
    EK.reverse()
    # print(EK)
    ek_str = ''
    for i in EK:
        ek_str  = ek_str + i
    x01_seq = find_x01_sequence(ek_str)
    return x01_seq

def generate():
    #create a  new DSA key
    key = DSA.generate(int(_sage_const_1024 ))

    # subgroup order is q
    f = open("q.pem", "w")
    print(key.q)
    f.write(str(key.q))
    f.close()

    # public_key is y
    f = open("public_key.pem", "w")
    print(key.y)
    f.write(str(key.y))
    f.close()

    # private key x
    f = open("private_key.pem", "w")
    print(hex(key.x))
    hex_key = hex(key.x)
    hex_key = hex_key.rstrip('L')
    hex_key = hex_key.lstrip('0x')
    f.write(str(key.x))
    f.close()

    # print(convert(key.x))
    message = b"Hello"
    bigList = []
    h = SHA.new(message).digest()
    with open("r_s_k_h.csv", "w") as f:
        for i in range(_sage_const_150 ):
            k = random.StrongRandom().randint(int(_sage_const_1 ), int(key.q-_sage_const_1 ))
            sig = key.sign(h, k)
            # S = (r-0, s-1, k-2, h(m)-3, l_a-4, l_b-5, l_c-6, a -7, c-8, number of bits leaked-9)
            print h
            shortList = [sig[_sage_const_0 ]*_sage_const_1p0 , sig[_sage_const_1 ]*_sage_const_1p0 , k, h, convert(k)]
            bigList.append(shortList)
        
if __name__ == "__main__":
    generate()

